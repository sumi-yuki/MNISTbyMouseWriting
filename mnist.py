# -*- coding: utf-8 -*-
"""mnist.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1VKVo53rnbuCUprl9j-SN-NJjQjcsJbYi
"""

!pip install tensorflow
!pip install tensorflowjs
!pip install matplotlib

"""
Created on Sun Sep  6 12:26:10 2020
@author: sumiyuuki
"""

# モジュールと呼ばれるすでに出来ているプログラム集を取り込みましょう
# 配列を扱うモジュールを取り込む
# npで配列を扱う関数などを指定できる
import numpy as np

# AIのモジュールを取り込む
import tensorflow
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Flatten, Dense, Dropout, Activation, Conv2D, MaxPooling2D
from tensorflow.keras.utils import to_categorical
from tensorflow.keras.datasets.mnist import load_data

# matplotlib.pyplotはグラフ表示のモジュール pltとして取り込む
import matplotlib.pyplot as plt
# 日本語表示
# 以下はAnaconda, Winpython用
# from matplotlib import rcParams
# rcParams['font.family'] ='sans-serif'
# rcParams['font.sans-serif'] = ['Hiragino Maru Gothic Pro', 'Yu Gothic', 'Meirio', 'IPAexGothic', 'IPAexMincho']
# 以下は日本語fontが無いGoogleColab, JupyterLab用
# https://moji.or.jp/ipafont/ipafontdownload/ から 2書体パック(IPAex明朝、IPAexゴシック) をダウンロード
# fonts の名前のフォルダーを作りそこに ipaexg.ttf と ipaexm.ttf をアップロードしておく
from matplotlib import font_manager
font_manager.fontManager.addfont("./fonts/ipaexg.ttf")
plt.rc('font', family="IPAexGothic")

# Model / data parameters
# 0から9まで10通りに分類する
num_classes = 10
# 元画像の画素数は横28ドット縦28ドット白黒のみ1(カラー画像はR[赤]G[緑]B[青]の3次元)
input_shape_mnist = (28, 28, 1)

# the data, split between train and test sets
# 元画像を読み込む
# 60,000枚の28x28，10個の数字の白黒画像と10,000枚のテスト用画像データセット．
# Deep Learningを教育するための教師データーとして(x_train, y_train)
# 教育されたDeep Learningの正答率を評価するためのデーターとして(x_test, y_test)
# Python の「タプル」形式で x_train は画像(手書きの数字)、 y_trainはその画像の表す数値
# x_train, x_test: shape (num_samples, 28, 28) の白黒画像データのuint8(0-255)配列．
# y_train, y_test: shape (num_samples,) のカテゴリラベル(0-9の整数)のuint8配列．

(x_train, y_train), (x_test, y_test) = load_data()

# Scale images to the [0, 1] range
# 元画像データー:0-255の整数を0-1の浮動小数点形式に変換
# np.astypeは型変換する関数
x_train = x_train.astype("float32") / 255
x_test = x_test.astype("float32") / 255

# Make sure images have shape (28, 28, 1)
# 画像を示す配列の形をDeep learning用に変更
# 例えば、x_train shape: (60000, 28, 28) を (60000, 28, 28, 1) にする
# np.expand_dimsは配列の次元を追加する関数
x_train = np.expand_dims(x_train, -1)
x_test = np.expand_dims(x_test, -1)
# データーが正しい形を持っているかチェックするため表示する
# np.shapeはNumPy配列ndarrayの次元数、形状（各次元のサイズ）、サイズ（全要素数）を取得する関数
print("x_train shape:", x_train.shape)
print("x_test shape:", x_test.shape)
print(x_train.shape[0], "train samples")
print(x_test.shape[0], "test samples")

# convert class vectors to binary class matrices
# 数字(正解)を示す配列の形をDeep learning用に変更
# 例えばy_train shape: (60000,)を(60000, 10)に変換
# tf.keras.utils.to_categorical(y, num_classes)は整数のクラスベクトルから2値クラスの行列への変換
# https://www.tensorflow.org/api_docs/python/tf/keras/utils/to_categorical
# 例えば0から9のでの数値を、10個の要素ある配列の対応する部分を1に、それ以外を0にする
y_train = to_categorical(y_train, num_classes)
y_test = to_categorical(y_test, num_classes)

# Deep learningを定義する
model = Sequential()

# 元画像の画素数は横28ドット縦28ドット白黒(カラー画像はR[赤]G[緑]B[青]の3チャンネル)
# input_shape_mnist = (28, 28, 1)
model.add(Conv2D(64, kernel_size=(3, 3), activation="relu", input_shape=input_shape_mnist))
#畳込み計算 出力空間の次元（つまり畳み込みにおける出力フィルタの数）が32、2次元の畳み込みウィンドウの幅3と高さ3
#https://keras.io/ja/layers/convolutional/次元

#この時点で上下左右1ドットずつとれて横28ドット縦28ドットの画像が横26ドット縦26ドットになっている
#フィルター数は16個をと指定しているので、この層では横26ドット縦26ドット画像が16存在する (26, 26, 16)の行列

#空間データのマックスプーリング(最大値をとる)演算． (2, 2) は画像（垂直，水平）をそれぞれの次元で半分にします．
#https://keras.io/ja/layers/pooling/
model.add(MaxPooling2D(pool_size=(2, 2)))
#上下左右2ドットで最も大きい値をとる　横26ドット縦26ドットの画像が横13ドット縦13ドットになっている
#画像数は16個で変わらず　この層では横13ドット縦13ドット画像が16存在する (13, 13, 16)の行列

model.add(Conv2D(128, kernel_size=(3, 3), activation="relu"))
#この時点で上下左右1ドットずつとれて横13ドット縦13ドットの画像が横11ドット縦11ドットになっている
#フィルター数は32個をと指定しているので、この層では横11ドット縦11ドット画像が32存在する (11, 11, 32)の行列

model.add(MaxPooling2D(pool_size=(2, 2)))
#上下左右2ドットで最も大きい値をとる　横11ドット縦11ドットの画像が横5ドット縦5ドットになっている 1ドットは
#画像数は32個で変わらず　この層では横5ドット縦5ドット画像が32存在する (5, 5, 32)の行列

#一次元に変換する(3次元から)
#https://keras.io/ja/layers/core/
model.add(Flatten())
#横5ドット縦5ドット画像が32枚を一次元800個に　(5, 5, 32)の行列を(800)の行列にする

#入力にドロップアウトを適用する．訓練時の更新においてランダムに入力ユニットを0とする割合であり，過学習の防止に役立ちます．
#https://keras.io/ja/layers/core/
#model.add(Dropout(0.5))

#通常の全結合ニューラルネットワークレイヤー．
#https://keras.io/ja/layers/core/
model.add(Dense(num_classes, activation="softmax"))
#800入力を　10出力にする全結合層

# 定義されたDeep learningの形を表示する
model.summary()

# 定義されたDeep learningネットワークを作る
model.compile(loss="categorical_crossentropy", optimizer="adam", metrics=["accuracy"])

# 60,000枚の画像を教師データーとしてDeep learningネットワークを教育し、誤差を少なくし正解を出すように教育する
# batchサイズはネットワークを更新するまで読み込む教師データー数
# batch_size = 128 とは128個読み込む毎に、正解に近づくようにネットワーク内のパラメーターを更新
# batch数を変えてみてください
batch_size = 128
# epoch数は学習回数
# epoch数を変えてみてください
epochs = 10
# historyに学習過程を記録する
history = model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, validation_split=0.2)

#10,000枚のテスト用画像データセットを用いて誤差と正答率を表示する
score = model.evaluate(x_test, y_test, verbose=0)
print("Test loss:", score[0])
print("Test accuracy:", score[1])

# 学習過程をグラフ表示する
history_dict = history.history
# Loss(正解との誤差)をloss_valuesに入れる
loss_values = history_dict['loss']
val_loss_values = history_dict['val_loss']
# 正確度をaccに入れる
acc = history_dict['accuracy']
val_acc = history_dict['val_accuracy']
# 1からepoch数までのリストを作る
epochlist = range(1, len(loss_values) +1)
#  正確度のグラフを作る
# 'b'は青い線
plt.plot(epochlist, acc, 'bo', label='Accuracy at training')
plt.plot(epochlist, val_acc, 'b', label='Accuracy at validation')
#  Loss(正解との誤差)のグラフを作る
# 'ro'は赤い点  https://matplotlib.org/api/_as_gen/matplotlib.pyplot.plot.html
plt.plot(epochlist, loss_values, 'ro', label='Loss at training')
plt.plot(epochlist, val_loss_values, 'r', label='Loss at validation')
#  タイトル
plt.title('学習回数と正確度、誤差')
plt.ylabel('青点は学習時正解率、青線は検証時正解率、赤点は学習時誤差、赤線は検証時誤差')
plt.xlabel('学習回数(epoch数)')
plt.legend()
#  グラフを表示する
plt.show()


# save the trained model for python
# model.save("mnist_model_tf")
# save the trained model for javascript
import tensorflowjs as tfjs
tfjs.converters.save_keras_model(model, "/content/drive/MyDrive/Colab Notebooks/mnist_model_js")